# The Ryu et al. 2020 method 

For reference code snippets and insight for how 3D Slicer works, please refer to the official 3D Slicer webpage [^1]. 

The Ryu et al. 2020[^2] method investigated multiple correlations between hard and soft tissue landmarks and measurement on 100 deceased Korean subjects. As  previous methods described by Ridel et al. (2018)[^3] and Lee et al. (2014)[^4], this method also features standardised planes which create the framework for 76 measurements. They describe 26 statistically significant regression equations predicting a soft tissue measurement from a single hard tissue measurement. As the definitions from hard tissue landmarks and measurements in relation to their planes provide a framework, unknown soft tissue measurements and consequently, soft tissue landmarks can be predicted based on their methods via "moving" a landmark from a known position along the planes and lengths predicted to a different position, acting as the predicted soft tissue landmark.

As with other tutorials, this one will focus on 
1) Reproducing the method in a situation where only hard tissue is available (predicted measurements); 
2) then investigating the predictive power via establishing the true measurements


### This document contains instructions for: 

> [!WARNING]
> The sample CT (CBCT PreDentalSurgery) used in the screenshots of this guide was taken pre-surgery for an underbite, the error rate shown in the guide is probably not representative if implemented on a population without pathologies.


### Landmarks in this guide (for prediction of soft tissues)


[Ryu_hard_tissue.mrk.json](https://github.com/user-attachments/files/21142552/Ryu_hard_tissue.mrk.json)


| Position in code | Position in file | Name in file | Landmark name | Definition | Defined by |
|------------------|------------------|--------------|---------------|------------|------------|
| 0 | 1 | N | nasion | Intersection of the nasofrontal sutures in the median plane | Ryu et al. 2020[^2]  |
| 1 | 15 | lambda | lambda | Point at which the two legs of the lambdoid suture and sagittal suture meet  | Martin (1928)[^6];   Knussman (1988)[^7]; Caple & Stephan (2016)[^5]  |
| 2 | 16 | prosthion | prosthion | Median point between the central incisors on the anterior most margin of the maxillary alveolar rim | Martin (1928)[^6];   Knussman (1988)[^7]; Caple & Stephan (2016)[^5]  |
| 3 | 17 | bregma | bregma | Where the sagittal and coronal sutures meet | Martin (1928)[^6];   Knussman (1988)[^7]; Caple & Stephan (2016)[^5] |
| 4 | 1 | O_L | left orbitale | Most inferior point on the left inferior orbital rim. Usually falls along the lateral half of the orbital margin | Martin (1928)[^6];   Knussman (1988)[^7]; Caple & Stephan (2016)[^5] |
| 5 | 2 | O_R | right orbitale | Most inferior point on theright inferior orbital rim. Usually falls along the lateral half of the orbital margin | Martin (1928)[^6];   Knussman (1988)[^7]; Caple & Stephan (2016)[^5] |
| 6 | 3 | por_L | left porion | Upper border of the right external auditory meatus or ear canal | Pittayapat et al. (2017)[^8]|
| 7 | 4 | por_R | right porion | Upper border of the left external auditory meatus or ear canal | Pittayapat et al. (2017)[^8] |
| 8 | 2 | R | rhinion | Most rostral (end) point on the internasal suture. Cannot be determined accurately if nasal bones are broken distally | Martin (1928)[^6];   Knussman (1988)[^7]; Caple & Stephan (2016)[^5] |
| 9 | 3 | AC | acanthion | Most anterior tip of the anterior nasal spine | Howells (1937)[^9]; Howells (1974)[^10]; Caple & Stephan (2016)[^5] |
| 10 | 7 | IC_L | left inferior concha | Point where the left inferior nasal concha is submerged into the medial wall of the nasal aperture |Ryu et al. 2020[^2]  |
| 11 | 8 | IC_R | right inferior concha | Point where the right inferior nasal concha is submerged into the medial wall of the nasal aperture | Ryu et al. 2020[^2] |
| 12 | 9 | A_L | left alare | Instrumentally determined as the most lateral point on the left of the nasal aperture in a transverse plane | Buikstra (1994)[^13]; Caple & Stephan (2016)[^5]  |
| 13 | 10 | A_R | right alare | Instrumentally determined as the most lateral point on the right of the nasal aperture in a transverse plane | Buikstra (1994)[^13]; Caple & Stephan (2016)[^5]  |
| 14 | 11 | NAG_L | left nasal aperture groove | Most posterior point on the left lateral curvature of the nasal aperture from profile view | Ryu et al. 2020[^2] |
| 15 | 12 | NAG_R | right nasal aperture groove | Most posterior point on the right lateral curvature of the nasal aperture from profile view |Ryu et al. 2020[^2]  |
| 16 | 13 | NAI_L | left nasal aperture inferior | Most inferior point on the left of the nasal aperture from the frontal view |Ryu et al. 2020[^2]  |
| 17 | 14 | NAI_R | right nasal aperture inferior | Most inferior point on the right of the nasal aperture from the frontal view | Ryu et al. 2020[^2] |

Soft tissue landmarks (ALLOCATION NOT NECESSARY for the prediction code to work)
[Ryu_soft_tissue.mrk.json](https://github.com/user-attachments/files/21109696/Ryu_soft_tissue.mrk.json)

| Position in code | Position in file | Name in file | Landmark name | Definition | Defined by |
|------------------|-----------------|--------------|---------------|------------|------------|
| 0 | 1 | S | selion | Deepest midline point of the nasofrontal angle | Kolar, 1997[^11]; Caple & Stephan (2016)[^5]  |
| 1 | 2 | PN | pronasale | Most anteriorly projected point on a nose | Ryu et al. 2020[^2]  |
| 2 | 3 | SN | SN | Median point at the junction between the lower border of the nasal septum and the philtrum area | Kolar, 1997[^11]; Caple & Stephan (2016)[^5] |
| 3 | 4 | ACS_L | ACS_L | Highest point on the left ala nasi (rounded wing shape of a nose) |  Ryu et al. 2020[^2] |
| 4 | 5 | ACS_R | ACS_R | Highest point on the right ala nasi (rounded wing shape of a nose) |  Ryu et al. 2020[^2] |
| 5 | 6 | ACP_L | ACP_L | Most posterolateral point of the left curvature of the base of the nasal alae |  Ryu et al. 2020[^2] |
|6 | 7 | ACP_R | ACP_R | Most posterolateral point of the right curvature of the base of the nasal alae |  Ryu et al. 2020[^2] |
| 7 | 8 | NA_L | NA_L | The most lateral point on the left nasal ala |  Ryu et al. 2020[^2] |
| 8 | 9 | NA_R | NA_R | The most lateral point on the right nasal ala |  Ryu et al. 2020[^2] |
| 9 | 10 | ACI_L | ACI_L | Most posterolateral point of the curvature of the base line of the left nasal ala |  Ryu et al. 2020[^2] |
| 10 | 11 | ACI_R | ACI_R | Most posterolateral point of the curvature of the base line of the right nasal ala |  Ryu et al. 2020[^2]|




### Illustration of the method


> [!WARNING]
> Before you proceed, please make sure you completed the following steps: 

- [ ] Re-aligned the scene in the FHP
- [ ] Allocated all hard tissue landmarks

### Reference planes & linear measurements from hard tissue landmarks in the study

The following code snippet creates both the reference planes and all linear hard tissue measurements based on the placed landmarks. These are summarised by the two tables below: 

<table>
  <thead>
    <tr>
      <th>Plane in scene</th>
      <th>Definition by Ryu et al. (2020)</th>
      <th>Coded using…</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Midsagittal</td>
      <td>Plane passing through the three landmarks, nasion, prosthion and lambda</td>
      <td></td>
    </tr>
    <tr>
      <td>Orbital</td>
      <td>Plane that passes through the two landmarks auriculare midpoint and orbitale and is orthogonal to the midsagittal plane</td>
      <td>4 bilateral landmarks, like FHP: l/R porions and L/R orbitale</td>
    </tr>
    <tr>
      <td>Coronal</td>
      <td>Plane that passes through one landmark, bregma and is orthogonal to the midsagittal plane and orbital plane</td>
      <td></td>
    </tr>
    <tr>
      <td>Rhinion</td>
      <td>Plane that passes through one landmark, rhinion and is parallel to the orbital plane</td>
      <td></td>
    </tr>
    <tr>
      <td>Left Alare Sagittal</td>
      <td>Plane that passes through one landmark, left alare and is parallel to the midsagittal plane</td>
      <td>sides separately</td>
    </tr>
    <tr>
      <td>Right Alare Sagittal</td>
      <td>Plane that passes through one landmark, right alare and is parallel to the midsagittal plane</td>
      <td></td>
    </tr>
  </tbody>
</table>

#### Hard tissue measurements

| Measurement Code | Landmark name | Landmark code | Tissue type | Landmark plane name |
|-----------------|---------------|--------------|------------|-------------------|
| N1 | Acanthion | AC | hard | Midsagittal |
| N2 | Acanthion | AC | hard | Left Alare Sagittal |
| N3 | Acanthion | AC | hard | Right Alare Sagittal |
| N4 | Nasion | N | hard | Orbital |
| N5 | Acanthion | AC | hard | Orbital |
| N6 | Nasion | N | hard | Coronal |
| N7 | Acanthion | AC | hard | Coronal |
| N8 | Sellion | S | soft | Midsagittal |
| N9 | Sellion | S | soft | Left Alare Sagittal |
| N10 | Sellion | S | soft | Right Alare Sagittal |
| N11 | Pronasale | PN | soft | Midsagittal |
| N12 | Pronasale | PN | soft | Left Alare Sagittal |
| N13 | Pronasale | PN | soft | Right Alare Sagittal |
| N14 | Subnasale | SN | soft | Midsagittal |
| N15 | Subnasale | SN | soft | Left Alare Sagittal |
| N16 | Subnasale | SN | soft | Right Alare Sagittal |
| N17 | Sellion | S | soft | Orbital |
| N18 | Pronasale | PN | soft | Orbital |
| N19 | Subnasale | SN | soft | Orbital |
| N20 | Sellion | S | soft | Coronal |
| N21 | Pronasale | PN | soft | Coronal |
| N22 | Subnasale | SN | soft | Coronal |
| N23 | Orbitale (L) | O_L | hard | Rhinion |
| N24 | Orbitale (R) | O_R | hard | Rhinion |
| N25 | Sellion | S | soft | Rhinion |
| N26 | Acanthion | AC | hard | Rhinion |
| N27 | Subnasale | SN | soft | Rhinion |
| N28 | Rhinion | R | hard | Coronal |
| N29 | Left Inferior Concha | IC_L | hard | Midsagittal |
| N30 | Left Alare | A_L | hard | Midsagittal |
| N31 | Left Nasal Greater wing | NAG_L | hard | Midsagittal |
| N32 | Left Nasal Inferior | NAI_L | hard | Midsagittal |
| N33 | Left Inferior Concha | IC_L | hard | Orbital |
| N34 | Left Alare | A_L | hard | Orbital |
| N35 | Left Nasal Greater wing | NAG_L | hard | Orbital |
| N36 | Left Nasal Inferior | NAI_L | hard | Orbital |
| N37 | Left Inferior Concha | IC_L | hard | Coronal |
| N38 | Left Alare | A_L | hard | Coronal |
| N39 | Left Nasal Greater wing | NAG_L | hard | Coronal |
| N40 | Left Nasal Inferior | NAI_L | hard | Coronal |
| N41 | Left Alar crease Superior | ACS_L | soft | Midsagittal |
| N42 | Left Alar crease Posterior | ACP_L | soft | Midsagittal |
| N43 | Left Nose | NA_L | soft | Midsagittal |
| N44 | Left Alar crease Inferior | ACI_L | soft | Midsagittal |
| N45 | Left Alar crease Superior | ACS_L | soft | Orbital |
| N46 | Left Alar crease Posterior | ACP_L | soft | Orbital |
| N47 | Left Nose | NA_L | soft | Orbital |
| N48 | Left Alar crease Inferior | ACI_L | soft | Orbital |
| N49 | Left Alar crease Superior | ACS_L | soft | Coronal |
| N50 | Left Alar crease Posterior | ACP_L | soft | Coronal |
| N51 | Left Nose | NA_L | soft | Coronal |
| N52 | Left Alar crease Inferior | ACI_L | soft | Coronal |
| N53 | Right Inferior Concha | IC_R | hard | Midsagittal |
| N54 | Right Nose | NA_R | soft | Midsagittal |
| N55 | Right Nasal Greater wing | NAG_R | hard | Midsagittal |
| N56 | Right Nasal Inferior | NAI_R | hard | Midsagittal |
| N57 | Right Inferior Concha | IC_R | hard | Orbital |
| N58 | Right Nose | NA_R | soft | Orbital |
| N59 | Right Nasal Greater wing | NAG_R | hard | Orbital |
| N60 | Right Nasal Inferior | NAI_R | hard | Orbital |
| N61 | Right Inferior Concha | IC_R | hard | Coronal |
| N62 | Right Nose | NA_R | soft | Coronal |
| N63 | Right Nasal Greater wing | NAG_R | hard | Coronal |
| N64 | Right Nasal Inferior | NAI_R | hard | Coronal |
| N65 | Right Alar crease Superior | ACS_R | soft | Midsagittal |
| N66 | Right Alar crease Posterior | ACP_R | soft | Midsagittal |
| N67 | Right Nose | NA_R | soft | Midsagittal |
| N68 | Right Alar crease Inferior | ACI_R | soft | Midsagittal |
| N69 | Right Alar crease Superior | ACS_R | soft | Orbital |
| N70 | Right Alar crease Posterior | ACP_R | soft | Orbital |
| N71 | Right Nose | NA_R | soft | Orbital |
| N72 | Right Alar crease Inferior | ACI_R | soft | Orbital |
| N73 | Right Alar crease Superior | ACS_R | soft | Coronal |
| N74 | Right Alar crease Posterior | ACP_R | soft | Coronal |
| N75 | Right Nose | NA_R | soft | Coronal |
| N76 | Right Alar crease Inferior | ACI_R | soft | Coronal |

<details>
<summary> Code for hard tissue planes and measurements </summary>

``` python
import slicer
import numpy as np
import vtk

def create_anatomical_planes():
    # Get landmarks node
    landmarksNode = slicer.util.getNode("Ryu_hard_tissue")
    
    # ==============================================
    # 1. Create Midsagittal Plane
    # ==============================================
    midsagittal_landmarks = ["N", "lambda", "prosthion"]
    points = []
    for i in range(landmarksNode.GetNumberOfControlPoints()):
        name = landmarksNode.GetNthControlPointLabel(i)
        if name in midsagittal_landmarks:
            points.append(landmarksNode.GetNthControlPointPosition(i))
    points = np.array(points)
    
    if points.shape[0] < 3:
        raise ValueError("At least three points are required to define Midsagittal plane.")
    
    centroid = points.mean(axis=0)
    _, _, vh = np.linalg.svd(points - centroid)
    normal = vh[2]
    
    midsagittalPlane = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsPlaneNode", "Midsagittal")
    midsagittalPlane.SetOrigin(centroid)
    midsagittalPlane.SetNormal(normal)
    
    displayNode = midsagittalPlane.GetDisplayNode()
    displayNode.SetColor(0.31, 0.78, 0.47)  # Emerald
    displayNode.SetSelectedColor(0.31, 0.78, 0.47)
    displayNode.SetOpacity(0.8)
    displayNode.SetVisibility(True)

    # ==============================================
    # 2. Create Orbital Plane (orthogonal to Midsagittal)
    # ==============================================
    orbital_landmarks = ["O_R", "O_L", "por_R", "por_L"]
    points = []
    for i in range(landmarksNode.GetNumberOfControlPoints()):
        name = landmarksNode.GetNthControlPointLabel(i)
        if name in orbital_landmarks:
            points.append(landmarksNode.GetNthControlPointPosition(i))
    points = np.array(points)
    
    if points.shape[0] < 3:
        raise ValueError("At least three points are required to define Orbital plane.")
    
    centroid = points.mean(axis=0)
    midsagittal_normal = np.array(midsagittalPlane.GetNormal())
    _, _, vh = np.linalg.svd(points - centroid)
    initial_normal = vh[2]
    
    # Make orthogonal to Midsagittal
    orthogonal_normal = initial_normal - np.dot(initial_normal, midsagittal_normal) * midsagittal_normal
    if np.linalg.norm(orthogonal_normal) > 0:
        orthogonal_normal /= np.linalg.norm(orthogonal_normal)
    else:
        if abs(midsagittal_normal[0]) > 0.1 or abs(midsagittal_normal[1]) > 0.1:
            orthogonal_normal = np.array([-midsagittal_normal[1], midsagittal_normal[0], 0])
        else:
            orthogonal_normal = np.array([0, -midsagittal_normal[2], midsagittal_normal[1]])
        orthogonal_normal /= np.linalg.norm(orthogonal_normal)
    
    orbitalPlane = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsPlaneNode", "Orbital")
    orbitalPlane.SetOrigin(centroid)
    orbitalPlane.SetNormal(orthogonal_normal)
    
    displayNode = orbitalPlane.GetDisplayNode()
    displayNode.SetColor(0.78, 0.31, 0.47)  # Purple
    displayNode.SetSelectedColor(0.78, 0.31, 0.47)
    displayNode.SetOpacity(0.8)
    displayNode.SetVisibility(True)

    # ==============================================
    # 3. Create Coronal Plane (orthogonal to both)
    # ==============================================
    bregma_point = None
    for i in range(landmarksNode.GetNumberOfControlPoints()):
        if landmarksNode.GetNthControlPointLabel(i) == "bregma":
            bregma_point = np.array(landmarksNode.GetNthControlPointPosition(i))
            break
    
    if bregma_point is None:
        raise ValueError("bregma landmark not found")
    
    coronal_normal = np.cross(midsagittal_normal, orthogonal_normal)
    coronal_normal /= np.linalg.norm(coronal_normal)
    
    coronalPlane = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsPlaneNode", "Coronal")
    coronalPlane.SetOrigin(bregma_point)
    coronalPlane.SetNormal(coronal_normal)
    
    displayNode = coronalPlane.GetDisplayNode()
    displayNode.SetColor(0.31, 0.47, 0.78)  # Blue
    displayNode.SetSelectedColor(0.31, 0.47, 0.78)
    displayNode.SetOpacity(0.8)
    displayNode.SetVisibility(True)

    # ==============================================
    # 4. Create Rhinion Plane (parallel to Orbital)
    # ==============================================
    rhinion_point = None
    for i in range(landmarksNode.GetNumberOfControlPoints()):
        if landmarksNode.GetNthControlPointLabel(i) == "R":
            rhinion_point = np.array(landmarksNode.GetNthControlPointPosition(i))
            break
    
    if rhinion_point is None:
        raise ValueError("R (rhinion) landmark not found")
    
    rhinionPlane = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsPlaneNode", "Rhinion")
    rhinionPlane.SetOrigin(rhinion_point)
    rhinionPlane.SetNormal(orbitalPlane.GetNormal())
    
    displayNode = rhinionPlane.GetDisplayNode()
    displayNode.SetColor(0.9, 0.7, 0.1)  # Gold
    displayNode.SetSelectedColor(0.9, 0.7, 0.1)
    displayNode.SetOpacity(0.8)
    displayNode.SetVisibility(True)

    # ==============================================
    # 5-6. Create Alare Sagittal Planes
    # ==============================================
    alare_landmarks = [("A_L", "Left Alare Sagittal"), ("A_R", "Right Alare Sagittal")]
    
    for landmark_name, plane_name in alare_landmarks:
        alare_point = None
        for i in range(landmarksNode.GetNumberOfControlPoints()):
            if landmarksNode.GetNthControlPointLabel(i) == landmark_name:
                alare_point = np.array(landmarksNode.GetNthControlPointPosition(i))
                break
        
        if alare_point is None:
            raise ValueError(f"{landmark_name} landmark not found")
        
        alarePlane = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsPlaneNode", plane_name)
        alarePlane.SetOrigin(alare_point)
        alarePlane.SetNormal(midsagittalPlane.GetNormal())
        
        displayNode = alarePlane.GetDisplayNode()
        if "Left" in plane_name:
            displayNode.SetColor(0.2, 0.8, 0.2)  # Green
        else:
            displayNode.SetColor(0.8, 0.2, 0.2)  # Red
        displayNode.SetSelectedColor(displayNode.GetColor())
        displayNode.SetOpacity(0.8)
        displayNode.SetVisibility(True)

    print("All anatomical planes created successfully!")
    return {
        "Midsagittal": midsagittalPlane,
        "Orbital": orbitalPlane,
        "Coronal": coronalPlane,
        "Rhinion": rhinionPlane,
        "Left Alare Sagittal": slicer.util.getNode("Left Alare Sagittal"),
        "Right Alare Sagittal": slicer.util.getNode("Right Alare Sagittal")
    }

def create_measurement_lines():
    # Only using hard tissue landmarks
    hard_tissue_node = slicer.util.getNode("Ryu_hard_tissue")
    
    # Define hard tissue measurements only
    hard_tissue_measurements = [
        ("N1", "AC", "Midsagittal"), ("N2", "AC", "Left Alare Sagittal"), ("N3", "AC", "Right Alare Sagittal"),
        ("N4", "N", "Orbital"), ("N5", "AC", "Orbital"), ("N6", "N", "Coronal"), ("N7", "AC", "Coronal"),
        ("N28", "R", "Coronal"),
        ("N29", "IC_L", "Midsagittal"), ("N30", "A_L", "Midsagittal"), ("N31", "NAG_L", "Midsagittal"), ("N32", "NAI_L", "Midsagittal"),
        ("N33", "IC_L", "Orbital"), ("N34", "A_L", "Orbital"), ("N35", "NAG_L", "Orbital"), ("N36", "NAI_L", "Orbital"),
        ("N37", "IC_L", "Coronal"), ("N38", "A_L", "Coronal"), ("N39", "NAG_L", "Coronal"), ("N40", "NAI_L", "Coronal"),
        ("N53", "IC_R", "Midsagittal"), ("N55", "NAG_R", "Midsagittal"), ("N56", "NAI_R", "Midsagittal"),
        ("N57", "IC_R", "Orbital"), ("N59", "NAG_R", "Orbital"), ("N60", "NAI_R", "Orbital"),
        ("N61", "IC_R", "Coronal"), ("N63", "NAG_R", "Coronal"), ("N64", "NAI_R", "Coronal")
    ]
    
    missing_landmarks = set()
    
    for line_name, landmark_name, plane_name in hard_tissue_measurements:
        point = None
        
        # Check for landmark in hard tissue only
        for i in range(hard_tissue_node.GetNumberOfControlPoints()):
            if hard_tissue_node.GetNthControlPointLabel(i) == landmark_name:
                point = np.array(hard_tissue_node.GetNthControlPointPosition(i))
                break
        
        if point is None:
            missing_landmarks.add(landmark_name)
            continue
        
        try:
            plane_node = slicer.util.getNode(plane_name)
        except slicer.util.MRMLNodeNotFoundException:
            print(f"Error: Plane '{plane_name}' not found for {line_name}")
            continue
        
        line_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", line_name)
        
        plane_normal = np.array(plane_node.GetNormal())
        plane_origin = np.array(plane_node.GetOrigin())
        v = point - plane_origin
        distance = np.dot(v, plane_normal)
        projected_point = point - distance * plane_normal
        
        line_node.AddControlPoint(point)
        line_node.AddControlPoint(projected_point)
        
        # Enable length measurement
        line_node.GetMeasurement('length').SetEnabled(True)
        line_node.GetMeasurement('length').SetName('Distance')
        
        # Set display properties
        display_node = line_node.GetDisplayNode()
        display_node.SetColor(1, 0, 0)  # Red for hard tissue
        display_node.SetSelectedColor(1, 1, 0)  # Yellow when selected
        display_node.SetTextScale(3)
        display_node.SetGlyphScale(1.5)
        display_node.SetPropertiesLabelVisibility(True)
        display_node.SetPointLabelsVisibility(True)
        
        print(f"Created {line_name}: {landmark_name} (hard tissue) to {plane_name} | Distance: {abs(distance):.2f} mm")
    
    if missing_landmarks:
        print("\nMissing landmarks:")
        for landmark in sorted(missing_landmarks):
            print(f" - {landmark}")

# Main execution
try:
    # First create the anatomical planes
    planes = create_anatomical_planes()
    
    # Then create the measurement lines
    create_measurement_lines()
    
    print("\nAll planes and hard tissue measurement lines created successfully!")
    slicer.util.delayDisplay("Processing Complete", 3000)
    
except Exception as e:
    print(f"\nError: {str(e)}")
    slicer.util.errorDisplay("An error occurred during processing. See Python console for details.")

```
</details>

You can expect the following view after the code: 


<img src="https://github.com/user-attachments/assets/e347e1f6-b189-4015-bb05-ea6da6182116" width="500">



Feel free to adjust the size of the visible planes (in theory, they are infinite, so this is just for visuals).


### Prediction regressions

The original study distinguished their regression equations based on biological sex, therefore an graphic user interface will offer you to choose the biological sex of the skull. Then the following equations are applied to first estimate the soft tissue linear measurements, then landmarks. 

| Sides   | Predicted Length | Regression for Males                | Regression for Females                | Common Plane |
|---------|------------------|-------------------------------------|---------------------------------------|--------------|
| midline | **N17**          | 0.92×**N4**−3.58                    | 0.85×**N4**−1.10                      | Orbital      |
| midline | **N18**          | 0.91×**N5**−6.84                    | 1.01×**N5**−9.04                      | Orbital      |
| midline | **N19**          | 0.91×**N5**+5.81                    | 1.00×**N5**+3.23                      | Orbital      |
| midline | **N20**          | 0.93×**N6**+11.28                   | 0.96×**N6**+8.36                      | Coronal      |
| midline | **N21**          | 0.96×**N7**+24.70                   | 1.00×**N7**+19.50                     | Coronal      |
| midline | **N22**          |            -                         | 1.02×**N7**+5.18                      | Orbital      |
| left    | **N45**          | 0.66×**N35**−3.97                   | 0.67×**N35**−3.71                     | Orbital      |
| right   | **N69**          | 0.62×**N59**−2.63                   | 0.66×**N59**−3.60                     | Orbital      |
| left    | **N46**          | 0.75×**N35**+3.07                   | 0.80×**N35**+3.27                     | Orbital      |
| right   | **N70**          | 0.75×**N59**+3.70                   | 0.77×**N59**+3.85                     | Orbital      |
| left    | **N47**          | 0.66×**N35**+6.72                   | 0.65×**N35**+6.73                     | Orbital      |
| right   | **N71**          | 0.66×**N59**+6.77                   | 0.78×**N59**+3.82                     | Orbital      |
| left    | **N48**          | 0.66×**N35**+14.01                  | 0.65×**N35**+13.58                    | Orbital      |
| right   | **N72**          | 0.69×**N59**+13.52                  | 0.65×**N59**+13.15                    | Coronal      |
| left    | **N49**          | 0.91×**N39**+19.98                  | 0.97×**N39**+14.07                    | Coronal      |
| right   | **N73**          | 0.92×**N63**+18.62                  | 0.90×**N63**+18.81                    | Coronal      |
| left    | **N50**          | 0.95×**N39**+10.59                  | 0.95×**N39**+10.26                    | Coronal      |
| right   | **N74**          | 0.99×**N63**+8.11                   | 1.00×**N63**+6.55                     | Coronal      |
| left    | **N51**          | 0.98×**N39**+12.26                  | 0.95×**N39**+12.71                    | Coronal      |
| right   | **N75**          | 1.02×**N63**+9.19                   | 1.03×**N63**+7.54                     | Coronal      |
| left    | **N52**          | 0.96×**N39**+15.18                  | 0.99×**N39**+11.45                    | Coronal      |
| right   | **N76**          | 0.99×**N63**+13.23                  | 1.02×**N63**+9.06                     | Coronal      |


The code's logic is the following: 

1. For midline soft tissue landmark prediction (S, PN, SN):
→Start at Nasion (N)
→ Move along Midsagittal plane (N8/N11/N14)
→ Adjust via Orbital plane (N17-19)
→ Finalize with Coronal plane (N20-22)

<details>
<summary> Code to visualise midline soft tissue landmark prediction </summary>

``` python
import slicer
import numpy as np

def visualize_pn_prediction():
    # Clear any previous visualization nodes
    for node in slicer.util.getNodesByClass('vtkMRMLMarkupsNode'):
        if node.GetName().startswith('Step_PN_') or node.GetName().startswith('Path_PN_'):
            slicer.mrmlScene.RemoveNode(node)
    
    # Step 1: Define which measurements we use for PN
    pn_measurements = ["N11", "N12", "N13", "N18", "N21"]
    print(f"Step 1: PN is defined using measurements: {', '.join(pn_measurements)}")
    
    # Step 2: Get plane nodes
    planes = {}
    plane_names = ["Midsagittal", "Left Alare Sagittal", "Right Alare Sagittal", "Orbital", "Coronal"]
    for name in plane_names:
        try:
            planes[name] = slicer.util.getNode(name)
            print(f"Step 2: Found plane: {name}")
        except:
            print(f"Warning: Plane {name} not found. Some steps may be skipped.")
    
    # Mapping from measurement to plane
    measurement_planes = {
        "N11": "Midsagittal",
        "N12": "Left Alare Sagittal",
        "N13": "Right Alare Sagittal",
        "N18": "Orbital",
        "N21": "Coronal"
    }
    
    # Step 3: Initialize position tracking variables
    current_point = None
    step_count = 0
    
    # Create path node to show the full journey
    path_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", "Path_PN_Prediction")
    path_node.GetDisplayNode().SetSelectedColor(0.5, 0.5, 1.0)  # Light blue
    path_node.GetDisplayNode().SetLineThickness(0.2)
    
    # Step 4: Process each measurement for PN
    for measurement in pn_measurements:
        print(f"\nChecking measurement {measurement}...")
        
        # Try to find the line (either predicted or original)
        try:
            try:
                line_node = slicer.util.getNode(f"Predicted_{measurement}")
                is_predicted = True
                print(f"Found predicted line: Predicted_{measurement}")
            except:
                line_node = slicer.util.getNode(measurement)
                is_predicted = False
                print(f"Found original line: {measurement}")
                
            # Get plane for this measurement
            plane_name = measurement_planes.get(measurement)
            if not plane_name or plane_name not in planes:
                print(f"Skipping: Plane {plane_name} not found for {measurement}")
                continue
                
            plane_node = planes[plane_name]
            plane_normal = np.array(plane_node.GetNormal())
            plane_origin = np.array(plane_node.GetOrigin())
            
            # Get measurement points
            if is_predicted:
                # Predicted line: plane to landmark direction
                landmark_pos = np.array(line_node.GetNthControlPointPosition(1))
                plane_point = np.array(line_node.GetNthControlPointPosition(0))
            else:
                # Original line: landmark to plane direction
                landmark_pos = np.array(line_node.GetNthControlPointPosition(0))
                plane_point = np.array(line_node.GetNthControlPointPosition(1))
            
            # Calculate movement vector
            movement_vector = landmark_pos - plane_point
            distance = np.linalg.norm(movement_vector)
            
            step_count += 1
            
            if current_point is None:
                # First measurement - starting point
                current_point = landmark_pos.copy()
                print(f"Step {step_count}: Initial position set from {measurement}")
                
                # Create a fiducial to mark the starting point
                start_point = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode", f"Step_PN_Start")
                start_point.AddControlPoint(current_point)
                start_point.SetNthControlPointLabel(0, f"Step 1: Start ({measurement})")
                start_point.GetDisplayNode().SetSelectedColor(0, 1, 0)  # Green
                start_point.GetDisplayNode().SetGlyphScale(3.0)
                start_point.GetDisplayNode().SetTextScale(3.0)
                
                # Add first point to the path
                path_node.AddControlPoint(current_point)
                
            else:
                # Apply movement vector to current position
                v = current_point - plane_origin
                d = np.dot(v, plane_normal)
                new_plane_point = current_point - d * plane_normal
                
                # Calculate the new position
                normalized_vector = movement_vector / distance if distance > 1e-5 else np.array([0,0,0])
                new_point = new_plane_point + normalized_vector * distance
                
                # Create a line to show the movement
                line = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", f"Step_PN_Line{step_count}")
                line.AddControlPoint(current_point)
                line.AddControlPoint(new_point)
                line.GetDisplayNode().SetSelectedColor(1, 0.5, 0)  # Orange
                line.GetDisplayNode().SetLineThickness(0.2)
                
                # Create point with label for this step
                step_point = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode", f"Step_PN_{step_count}")
                step_point.AddControlPoint(new_point)
                step_point.SetNthControlPointLabel(0, f"Step {step_count}: Using {measurement}")
                step_point.GetDisplayNode().SetSelectedColor(1, 0.7, 0)  # Orange-yellow
                step_point.GetDisplayNode().SetGlyphScale(2.5)
                step_point.GetDisplayNode().SetTextScale(3.0)
                
                # Add this point to the path
                path_node.AddControlPoint(new_point)
                
                # Update current position for next iteration
                print(f"Step {step_count}: Moved from previous position using {measurement}")
                print(f"  - Distance moved: {np.linalg.norm(new_point - current_point):.2f} mm")
                current_point = new_point
                
        except Exception as e:
            print(f"Error processing {measurement}: {str(e)}")
    
    # Final step: Mark the final predicted position
    if current_point is not None:
        final_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode", "Step_PN_Final")
        final_node.AddControlPoint(current_point)
        final_node.SetNthControlPointLabel(0, "Final PN Position")
        final_node.GetDisplayNode().SetSelectedColor(1, 0, 0)  # Red
        final_node.GetDisplayNode().SetGlyphScale(5.0)
        final_node.GetDisplayNode().SetTextScale(4.0)
        print(f"\nFinal PN position predicted at: [{current_point[0]:.2f}, {current_point[1]:.2f}, {current_point[2]:.2f}]")
    else:
        print("Could not predict PN position - no valid measurements found")

# Run the visualization
try:
    visualize_pn_prediction()
except Exception as e:
    slicer.util.errorDisplay(f"Error: {str(e)}")
```

</details>

![Picture3](https://github.com/user-attachments/assets/c6a5073e-f804-4cbd-8261-f2c08559bfbb)


2. For bilateral landmarks (ACS/ACP/NA/ACI):
→Start at respective hard tissue alare (A_L/A_R)
→ Move along Alare Sagittal plane (same side as the hard tissue alare)
→ Adjust via Orbital plane measurements
→ Finalize with Coronal plane measurements


![image](https://github.com/user-attachments/assets/a5b688a6-9964-42d3-a44c-1fec9ff2c5c8)


<details>
<summary> Code to visualise bilateral soft tissue landmark prediction </summary>

``` python
import slicer
import numpy as np

def visualize_acpl_prediction():
    # Clear any previous visualization nodes
    for node in slicer.util.getNodesByClass('vtkMRMLMarkupsNode'):
        if node.GetName().startswith('Step_ACP_L_') or node.GetName().startswith('Path_ACP_L_'):
            slicer.mrmlScene.RemoveNode(node)
    
    # Step 1: Define which measurements we use for ACP_L
    # These are typical measurements for alar curvature point - adjust if needed
    acpl_measurements = ["N42", "N46", "N50"]
    print(f"Step 1: ACP_L is defined using measurements: {', '.join(acpl_measurements)}")
    
    # Step 2: Get plane nodes
    planes = {}
    plane_names = ["Midsagittal", "Orbital", "Coronal"]
    for name in plane_names:
        try:
            planes[name] = slicer.util.getNode(name)
            print(f"Step 2: Found plane: {name}")
        except:
            print(f"Warning: Plane {name} not found. Some steps may be skipped.")
    
    # Mapping from measurement to plane
    measurement_planes = {
        "N42": "Midsagittal",
        "N46": "Orbital",
        "N50": "Coronal"
    }
    
    # Step 3: Initialize position tracking variables
    current_point = None
    step_count = 0
    
    # Create path node to show the full journey
    path_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", "Path_ACP_L_Prediction")
    path_node.GetDisplayNode().SetSelectedColor(0.5, 0.5, 1.0)  # Light blue
    path_node.GetDisplayNode().SetLineThickness(0.2)  # Thin line as requested
    
    # Step 4: Process each measurement for ACP_L
    for measurement in acpl_measurements:
        print(f"\nChecking measurement {measurement}...")
        
        # Try to find the line (either predicted or original)
        try:
            try:
                line_node = slicer.util.getNode(f"Predicted_{measurement}")
                is_predicted = True
                print(f"Found predicted line: Predicted_{measurement}")
            except:
                line_node = slicer.util.getNode(measurement)
                is_predicted = False
                print(f"Found original line: {measurement}")
                
            # Get plane for this measurement
            plane_name = measurement_planes.get(measurement)
            if not plane_name or plane_name not in planes:
                print(f"Skipping: Plane {plane_name} not found for {measurement}")
                continue
                
            plane_node = planes[plane_name]
            plane_normal = np.array(plane_node.GetNormal())
            plane_origin = np.array(plane_node.GetOrigin())
            
            # Get measurement points
            if is_predicted:
                # Predicted line: plane to landmark direction
                landmark_pos = np.array(line_node.GetNthControlPointPosition(1))
                plane_point = np.array(line_node.GetNthControlPointPosition(0))
            else:
                # Original line: landmark to plane direction
                landmark_pos = np.array(line_node.GetNthControlPointPosition(0))
                plane_point = np.array(line_node.GetNthControlPointPosition(1))
            
            # Calculate movement vector
            movement_vector = landmark_pos - plane_point
            distance = np.linalg.norm(movement_vector)
            
            step_count += 1
            
            if current_point is None:
                # First measurement - starting point
                current_point = landmark_pos.copy()
                print(f"Step {step_count}: Initial position set from {measurement}")
                
                # Create a fiducial to mark the starting point
                start_point = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode", f"Step_ACP_L_Start")
                start_point.AddControlPoint(current_point)
                start_point.SetNthControlPointLabel(0, f"Step 1: Start ({measurement})")
                start_point.GetDisplayNode().SetSelectedColor(0, 1, 0)  # Green
                start_point.GetDisplayNode().SetGlyphScale(2.0)
                start_point.GetDisplayNode().SetTextScale(3.0)
                
                # Add first point to the path
                path_node.AddControlPoint(current_point)
                
            else:
                # Apply movement vector to current position
                v = current_point - plane_origin
                d = np.dot(v, plane_normal)
                new_plane_point = current_point - d * plane_normal
                
                # Calculate the new position
                normalized_vector = movement_vector / distance if distance > 1e-5 else np.array([0,0,0])
                new_point = new_plane_point + normalized_vector * distance
                
                # Create a line to show the movement
                line = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", f"Step_ACP_L_Line{step_count}")
                line.AddControlPoint(current_point)
                line.AddControlPoint(new_point)
                line.GetDisplayNode().SetSelectedColor(1, 0.5, 0)  # Orange
                line.GetDisplayNode().SetLineThickness(0.2)  # Thin line as requested
                
                # Create point with label for this step
                step_point = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode", f"Step_ACP_L_{step_count}")
                step_point.AddControlPoint(new_point)
                step_point.SetNthControlPointLabel(0, f"Step {step_count}: Using {measurement}")
                step_point.GetDisplayNode().SetSelectedColor(1, 0.7, 0)  # Orange-yellow
                step_point.GetDisplayNode().SetGlyphScale(1.5)
                step_point.GetDisplayNode().SetTextScale(2.5)
                
                # Add this point to the path
                path_node.AddControlPoint(new_point)
                
                # Update current position for next iteration
                print(f"Step {step_count}: Moved from previous position using {measurement}")
                print(f"  - Distance moved: {np.linalg.norm(new_point - current_point):.2f} mm")
                current_point = new_point
                
        except Exception as e:
            print(f"Error processing {measurement}: {str(e)}")
    
    # Final step: Mark the final predicted position
    if current_point is not None:
        final_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsFiducialNode", "Step_ACP_L_Final")
        final_node.AddControlPoint(current_point)
        final_node.SetNthControlPointLabel(0, "Final ACP_L Position")
        final_node.GetDisplayNode().SetSelectedColor(1, 0, 0)  # Red
        final_node.GetDisplayNode().SetGlyphScale(3.0)
        final_node.GetDisplayNode().SetTextScale(3.0)
        print(f"\nFinal ACP_L position predicted at: [{current_point[0]:.2f}, {current_point[1]:.2f}, {current_point[2]:.2f}]")
    else:
        print("Could not predict ACP_L position - no valid measurements found")

# Run the visualization
try:
    visualize_acpl_prediction()
except Exception as e:
    slicer.util.errorDisplay(f"Error: {str(e)}")
```

</details>


![image](https://github.com/user-attachments/assets/7638f90e-953d-4cde-b9cf-d04f644b2c72)

<details>
<summary> GUI code for prediction of soft tissue landmarks </summary>

``` python
import slicer
from qt import QWidget, QVBoxLayout, QComboBox, QPushButton, QLabel
import numpy as np

class SoftTissuePredictorUI(QWidget):
    def __init__(self):
        super().__init__()
        self.predicted_landmarks_node = None
        self.initUI()
        
    def initUI(self):
        # Main layout
        main_layout = QVBoxLayout()
        self.setLayout(main_layout)
        self.setWindowTitle("Soft Tissue Predictor")
        
        # Biological sex selection
        main_layout.addWidget(QLabel("Select Biological Sex:"))
        self.sex_combo = QComboBox()
        self.sex_combo.addItems(["Male", "Female"])
        main_layout.addWidget(self.sex_combo)
        
        # Prediction button
        self.predict_btn = QPushButton("Predict Soft Tissue")
        self.predict_btn.clicked.connect(self.run_prediction_pipeline)
        main_layout.addWidget(self.predict_btn)
        
        # Status label
        self.status_label = QLabel("Ready to predict")
        main_layout.addWidget(self.status_label)
        
        self.resize(400, 200)
    
    def run_prediction_pipeline(self):
        # FIXED: Using index and itemText instead of currentText
        index = self.sex_combo.currentIndex
        if callable(index):  # Handle both property and method cases
            index = index()
            
        biological_sex = self.sex_combo.itemText(index)
        
        self.status_label.setText(f"Predicting for {biological_sex}...")
        slicer.app.processEvents()
        
        try:
            # 1. Predict soft tissue measurements
            predicted_distances = self.predict_soft_tissue_measurements(biological_sex)
            
            # 2. Create predicted lines
            self.create_predicted_soft_lines(predicted_distances, biological_sex)
            
            # 3. Derive landmark positions using sequential vector method
            self.predict_soft_landmarks_sequential_vector()
            
            self.status_label.setText("Prediction complete!")
            slicer.util.delayDisplay("Prediction Complete", 3000)
            
        except Exception as e:
            self.status_label.setText(f"Error: {str(e)}")
            slicer.util.errorDisplay(f"Prediction failed: {str(e)}")
    
    def predict_soft_tissue_measurements(self, gender):
        """Predict soft tissue measurements using regression equations"""
        # Get all existing measurement lines
        measurements = {}
        line_nodes = slicer.util.getNodesByClass("vtkMRMLMarkupsLineNode")
        for line_node in line_nodes:
            name = line_node.GetName()
            if name.startswith("N") and name[1:].isdigit():
                measurements[name] = line_node.GetMeasurement('length').GetValue()
        
        # Dictionary to store predicted distances
        predicted_distances = {}
        
        # Regression equations by gender
        if gender.lower() == "male":
            regressions = {
                "N17": lambda: 0.92 * measurements.get("N4", 0) - 3.58,
                "N18": lambda: 0.91 * measurements.get("N5", 0) - 6.84,
                "N19": lambda: 0.91 * measurements.get("N5", 0) + 5.81,
                "N20": lambda: 0.93 * measurements.get("N6", 0) + 11.28,
                "N21": lambda: 0.96 * measurements.get("N7", 0) + 24.70,
                "N22": lambda: 0.96 * measurements.get("N7", 0) + 8.0,  # Estimated value for male
                "N45": lambda: 0.66 * measurements.get("N35", 0) - 3.97,
                "N69": lambda: 0.62 * measurements.get("N59", 0) - 2.63,
                "N46": lambda: 0.75 * measurements.get("N35", 0) + 3.07,
                "N70": lambda: 0.75 * measurements.get("N59", 0) + 3.70,
                "N47": lambda: 0.66 * measurements.get("N35", 0) + 6.72,
                "N71": lambda: 0.66 * measurements.get("N59", 0) + 6.77,
                "N48": lambda: 0.66 * measurements.get("N35", 0) + 14.01,
                "N72": lambda: 0.69 * measurements.get("N59", 0) + 13.52,
                "N49": lambda: 0.91 * measurements.get("N39", 0) + 19.98,
                "N73": lambda: 0.92 * measurements.get("N63", 0) + 18.62,
                "N50": lambda: 0.95 * measurements.get("N39", 0) + 10.59,
                "N74": lambda: 0.99 * measurements.get("N63", 0) + 8.11,
                "N51": lambda: 0.98 * measurements.get("N39", 0) + 12.26,
                "N75": lambda: 1.02 * measurements.get("N63", 0) + 9.19,
                "N52": lambda: 0.96 * measurements.get("N39", 0) + 15.18,
                "N76": lambda: 0.99 * measurements.get("N63", 0) + 13.23
            }
        else:  # Female
            regressions = {
                "N17": lambda: 0.85 * measurements.get("N4", 0) - 1.10,
                "N18": lambda: 1.01 * measurements.get("N5", 0) - 9.04,
                "N19": lambda: 1.00 * measurements.get("N5", 0) + 3.23,
                "N20": lambda: 0.96 * measurements.get("N6", 0) + 8.36,
                "N21": lambda: 1.00 * measurements.get("N7", 0) + 19.50,
                "N22": lambda: 1.02 * measurements.get("N7", 0) + 5.18,
                "N45": lambda: 0.67 * measurements.get("N35", 0) - 3.71,
                "N69": lambda: 0.66 * measurements.get("N59", 0) - 3.60,
                "N46": lambda: 0.80 * measurements.get("N35", 0) + 3.27,
                "N70": lambda: 0.77 * measurements.get("N59", 0) + 3.85,
                "N47": lambda: 0.65 * measurements.get("N35", 0) + 6.73,
                "N71": lambda: 0.78 * measurements.get("N59", 0) + 3.82,
                "N48": lambda: 0.65 * measurements.get("N35", 0) + 13.58,
                "N72": lambda: 0.65 * measurements.get("N59", 0) + 13.15,
                "N49": lambda: 0.97 * measurements.get("N39", 0) + 14.07,
                "N73": lambda: 0.90 * measurements.get("N63", 0) + 18.81,
                "N50": lambda: 0.95 * measurements.get("N39", 0) + 10.26,
                "N74": lambda: 1.00 * measurements.get("N63", 0) + 6.55,
                "N51": lambda: 0.95 * measurements.get("N39", 0) + 12.71,
                "N75": lambda: 1.03 * measurements.get("N63", 0) + 7.54,
                "N52": lambda: 0.99 * measurements.get("N39", 0) + 11.45,
                "N76": lambda: 1.02 * measurements.get("N63", 0) + 9.06
            }
        
        # Calculate predicted distances
        for soft_code, equation in regressions.items():
            try:
                predicted_distances[soft_code] = equation()
                # Check for invalid values
                if np.isnan(predicted_distances[soft_code]) or predicted_distances[soft_code] <= 0:
                    print(f"Warning: Invalid prediction for {soft_code}: {predicted_distances[soft_code]}")
                    del predicted_distances[soft_code]
            except Exception as e:
                print(f"Couldn't calculate {soft_code}: {str(e)}")
        
        return predicted_distances
    
    def create_predicted_soft_lines(self, predicted_distances, gender):
        """Create predicted soft tissue lines with proper directionality"""
        # Clear existing predicted lines
        self.remove_predicted_lines()
        
        # Get plane nodes
        planes = {}
        plane_names = ["Midsagittal", "Orbital", "Coronal", "Rhinion", 
                      "Left Alare Sagittal", "Right Alare Sagittal"]
        for name in plane_names:
            try:
                planes[name] = slicer.util.getNode(name)
            except slicer.util.MRMLNodeNotFoundException:
                print(f"Plane {name} not found")
        
        # Consistent measurement to plane mapping
        measurement_planes = {
            "N17": "Orbital", "N18": "Orbital", "N19": "Orbital",
            "N20": "Coronal", "N21": "Coronal", "N22": "Coronal", 
            "N45": "Orbital", "N46": "Orbital", "N47": "Orbital", "N48": "Orbital",
            "N49": "Coronal", "N50": "Coronal", "N51": "Coronal", "N52": "Coronal",
            "N69": "Orbital", "N70": "Orbital", "N71": "Orbital", "N72": "Orbital", 
            "N73": "Coronal", "N74": "Coronal", "N75": "Coronal", "N76": "Coronal",
            "N8": "Midsagittal", "N9": "Left Alare Sagittal", "N10": "Right Alare Sagittal",
            "N11": "Midsagittal", "N12": "Left Alare Sagittal", "N13": "Right Alare Sagittal",
            "N14": "Midsagittal", "N15": "Left Alare Sagittal", "N16": "Right Alare Sagittal",
            "N1": "Midsagittal", "N2": "Left Alare Sagittal", "N3": "Right Alare Sagittal",
            "N4": "Orbital", "N5": "Orbital", "N6": "Coronal", "N7": "Coronal",
            "N23": "Rhinion", "N24": "Rhinion", "N25": "Rhinion", "N26": "Rhinion", "N27": "Rhinion", "N28": "Coronal",
            "N29": "Midsagittal", "N30": "Midsagittal", "N31": "Midsagittal", "N32": "Midsagittal",
            "N33": "Orbital", "N34": "Orbital", "N35": "Orbital", "N36": "Orbital",
            "N37": "Coronal", "N38": "Coronal", "N39": "Coronal", "N40": "Coronal",
            "N41": "Midsagittal", "N42": "Midsagittal", "N43": "Midsagittal", "N44": "Midsagittal",
            "N53": "Midsagittal", "N54": "Midsagittal", "N55": "Midsagittal", "N56": "Midsagittal",
            "N57": "Orbital", "N58": "Orbital", "N59": "Orbital", "N60": "Orbital",
            "N61": "Coronal", "N62": "Coronal", "N63": "Coronal", "N64": "Coronal",
            "N65": "Midsagittal", "N66": "Midsagittal", "N67": "Midsagittal", "N68": "Midsagittal",
        }
        
        # Dependency map for soft->hard measurements
        dependency_map = {
            "N17": "N4", "N18": "N5", "N19": "N5",
            "N20": "N6", "N21": "N7", "N22": "N7",
            "N45": "N35", "N46": "N35", "N47": "N35", "N48": "N35",
            "N49": "N39", "N50": "N39", "N51": "N39", "N52": "N39",
            "N69": "N59", "N70": "N59", "N71": "N59", "N72": "N59",
            "N73": "N63", "N74": "N63", "N75": "N63", "N76": "N63"
        }
        
        # Create predicted lines
        for soft_code, distance in predicted_distances.items():
            plane_name = measurement_planes.get(soft_code)
            if not plane_name:
                print(f"Skipping {soft_code}: No plane mapping")
                continue
                
            plane_node = planes.get(plane_name)
            if not plane_node:
                print(f"Skipping {soft_code}: Plane {plane_name} not found")
                continue
                
            # Get corresponding hard tissue measurement
            hard_code = dependency_map.get(soft_code, soft_code)  # Default to same code if no mapping
            try:
                hard_line = slicer.util.getNode(hard_code)
                if not hard_line:
                    print(f"Skipping {soft_code}: Hard line {hard_code} not found")
                    continue
                    
                # Get direction from hard line (point 0 is landmark, point 1 is plane projection)
                landmark_pos = np.array(hard_line.GetNthControlPointPosition(0))
                plane_proj_pos = np.array(hard_line.GetNthControlPointPosition(1))
                direction = landmark_pos - plane_proj_pos
                
                # Verify valid direction vector
                direction_norm = np.linalg.norm(direction)
                if direction_norm < 1e-5:  # Very small, almost zero
                    print(f"Warning: Direction vector for {soft_code} is nearly zero. Using default.")
                    # Use default direction (perpendicular to plane)
                    direction = np.array(plane_node.GetNormal())
                else:
                    direction = direction / direction_norm
                
                # Calculate new landmark position
                plane_origin = np.array(plane_node.GetOrigin())
                plane_normal = np.array(plane_node.GetNormal())
                
                # Find point on plane closest to original projection
                v = plane_proj_pos - plane_origin
                d = np.dot(v, plane_normal)
                plane_point = plane_proj_pos - d * plane_normal
                
                # Create new point along same direction but with predicted distance
                new_landmark_pos = plane_point + direction * distance
                
                # Create the predicted line
                line_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", f"Predicted_{soft_code}")
                line_node.AddControlPoint(plane_point)
                line_node.AddControlPoint(new_landmark_pos)
                
                # Create display node if needed
                display_node = line_node.GetDisplayNode()
                if not display_node:
                    display_node = line_node.CreateDefaultDisplayNodes()
                
                # Set styling
                display_node.SetColor(0, 1, 1)  # Cyan
                display_node.SetSelectedColor(1, 1, 0)  # Yellow
                display_node.SetTextScale(3)
                display_node.SetGlyphScale(1.5)
                
                # Enable measurement
                line_node.GetMeasurement('length').SetEnabled(True)
                line_node.GetMeasurement('length').SetName('Distance')
                
            except Exception as e:
                print(f"Skipping {soft_code}: {str(e)}")
    
    def remove_predicted_lines(self):
        """Remove all previously predicted lines"""
        line_nodes = slicer.util.getNodesByClass("vtkMRMLMarkupsLineNode")
        nodes_to_remove = []
        for line_node in line_nodes:
            if line_node.GetName().startswith("Predicted_"):
                nodes_to_remove.append(line_node)
        
        for node in nodes_to_remove:
            slicer.mrmlScene.RemoveNode(node)
    
    def predict_soft_landmarks_sequential_vector(self):
        """Predict soft tissue landmarks using sequential vector movement"""
        # Mapping of landmarks to their defining measurements
        landmark_definitions = {
            "S": ["N8", "N9", "N10", "N17", "N20"],  # Selion
            "PN": ["N11", "N12", "N13", "N18", "N21"],  # Pronasale
            "SN": ["N14", "N15", "N16", "N19", "N22"],  # Subnasale
            "ACS_L": ["N41", "N45", "N49"],  # Alar curvature superior left
            "ACS_R": ["N65", "N69", "N73"],  # Alar curvature superior right
            "ACP_L": ["N42", "N46", "N50"],  # Alar curvature posterior left
            "ACP_R": ["N66", "N70", "N74"],  # Alar curvature posterior right
            "NA_L": ["N43", "N47", "N51"],   # Nasal alare left
            "NA_R": ["N67", "N71", "N75"],   # Nasal alare right
            "ACI_L": ["N44", "N48", "N52"],   # Alar curvature inferior left
            "ACI_R": ["N68", "N72", "N76"]    # Alar curvature inferior right
        }
        
        # Get all plane nodes
        planes_dict = {}
        plane_names = ["Midsagittal", "Orbital", "Coronal", "Rhinion", 
                      "Left Alare Sagittal", "Right Alare Sagittal"]
        for name in plane_names:
            try:
                planes_dict[name] = slicer.util.getNode(name)
            except slicer.util.MRMLNodeNotFoundException:
                print(f"Plane {name} not found")
        
        # Update measurement to plane mapping to be consistent
        measurement_planes = {
            "N8": "Midsagittal", "N9": "Left Alare Sagittal", "N10": "Right Alare Sagittal",
            "N11": "Midsagittal", "N12": "Left Alare Sagittal", "N13": "Right Alare Sagittal",
            "N14": "Midsagittal", "N15": "Left Alare Sagittal", "N16": "Right Alare Sagittal",
            "N17": "Orbital", "N18": "Orbital", "N19": "Orbital",
            "N20": "Coronal", "N21": "Coronal", "N22": "Coronal",
            "N41": "Midsagittal", "N42": "Midsagittal", "N43": "Midsagittal", "N44": "Midsagittal",
            "N45": "Orbital", "N46": "Orbital", "N47": "Orbital", "N48": "Orbital",
            "N49": "Coronal", "N50": "Coronal", "N51": "Coronal", "N52": "Coronal",
            "N65": "Midsagittal", "N66": "Midsagittal", "N67": "Midsagittal", "N68": "Midsagittal",
            "N69": "Orbital", "N70": "Orbital", "N71": "Orbital", "N72": "Orbital",
            "N73": "Coronal", "N74": "Coronal", "N75": "Coronal", "N76": "Coronal"
        }
        
        predicted_landmarks = {}
        
        # Improved landmark prediction logic with better error handling
        for landmark, measurement_codes in landmark_definitions.items():
            # Start from a known reference point - use the first available measurement
            current_point = None
            valid_measurements = 0
            
            for code in measurement_codes:
                try:
                    # First try to get predicted line
                    try:
                        line_node = slicer.util.getNode(f"Predicted_{code}")
                        is_predicted = True
                    except:
                        # If not found, try original line
                        line_node = slicer.util.getNode(code)
                        is_predicted = False
                        
                    # Skip if line not found or doesn't have enough points
                    if not line_node or line_node.GetNumberOfControlPoints() < 2:
                        continue
                        
                    # Get plane for this measurement
                    plane_name = measurement_planes.get(code)
                    if not plane_name or plane_name not in planes_dict:
                        continue
                        
                    plane_node = planes_dict[plane_name]
                    plane_normal = np.array(plane_node.GetNormal())
                    plane_origin = np.array(plane_node.GetOrigin())
                    
                    # Get movement vector
                    if is_predicted:
                        # Predicted line: movement from plane to landmark
                        landmark_pos = np.array(line_node.GetNthControlPointPosition(1))
                        plane_proj_pos = np.array(line_node.GetNthControlPointPosition(0))
                    else:
                        # Original line: movement from plane to landmark
                        landmark_pos = np.array(line_node.GetNthControlPointPosition(0))
                        plane_proj_pos = np.array(line_node.GetNthControlPointPosition(1))
                        
                    # Calculate movement vector
                    movement_vector = landmark_pos - plane_proj_pos
                    distance = np.linalg.norm(movement_vector)
                    if distance > 1e-5:  # Avoid division by zero
                        movement_vector = movement_vector / distance
                    else:
                        print(f"Warning: Zero distance in {code} for {landmark}")
                        continue
                    
                    if current_point is None:
                        # First measurement - set starting point
                        current_point = landmark_pos.copy()
                        valid_measurements += 1
                    else:
                        # Apply movement to current point
                        v = current_point - plane_origin
                        d = np.dot(v, plane_normal)
                        plane_point = current_point - d * plane_normal
                        current_point = plane_point + movement_vector * distance
                        valid_measurements += 1
                
                except Exception as e:
                    print(f"Error processing {code} for {landmark}: {str(e)}")
            
            if current_point is not None and valid_measurements > 0:
                predicted_landmarks[landmark] = current_point
                print(f"Predicted {landmark} using {valid_measurements} measurements")
            else:
                print(f"Skipping {landmark}: No valid measurements found")
        
        # Create or update predicted landmarks node
        if self.predicted_landmarks_node:
            slicer.mrmlScene.RemoveNode(self.predicted_landmarks_node)
        
        self.predicted_landmarks_node = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLMarkupsFiducialNode", 
            "Predicted_Soft_Landmarks"
        )
        
        # Ensure display node exists
        display_node = self.predicted_landmarks_node.GetDisplayNode()
        if not display_node:
            display_node = self.predicted_landmarks_node.CreateDefaultDisplayNodes()
        
        # Styling
        display_node.SetColor(0, 0.8, 0.8)  # Teal
        display_node.SetSelectedColor(1, 1, 0)  # Yellow
        display_node.SetGlyphScale(1.5)
        display_node.SetTextScale(3)
        
        # Add predicted landmarks
        for name, pos in predicted_landmarks.items():
            self.predicted_landmarks_node.AddControlPoint(pos, name)

# Create and show the UI
predictor_ui = SoftTissuePredictorUI()
predictor_ui.show()
```
</details>


 The code will produce predicted linear measurement and a new point list called **Predicted_Soft_Landmarks** containing the predicted landmarks.

### Measuring the prediction errors

To establish the difference between the predicted and true measurments as well as the placement of the predicted soft tissue landmarks to the true soft tissue landmarks, allocate the contents of the _Ryu_soft_tissue.mrk.json_. 


The following code will create the true soft tissue measurements based on the true soft tissue landmarks (N8-N22, N25, N27, N41-52, N54, N58, N62, N65-76) and draws a line between the predicted soft tissue landmark stored in "Predicted_Soft_Landmarks" and the true landmarks in "Ryu_soft_tissue". 

| Measurement Code | Landmark                  | Name in "Ryu_soft_tissue" | Landmark Tissue Type | Plane Name in Scene      |
|------------------|--------------------------|---------------------------|---------------------|-------------------------|
| N8               | Selion                   | S                         | soft                | Midsagittal             |
| N9               | Selion                   | S                         | soft                | Left Alare Sagittal     |
| N10              | Selion                   | S                         | soft                | Right Alare Sagittal    |
| N11              | Pronasale                | PN                        | soft                | Midsagittal             |
| N12              | Pronasale                | PN                        | soft                | Left Alare Sagittal     |
| N13              | Pronasale                | PN                        | soft                | Right Alare Sagittal    |
| N14              | Subnasale                | SN                        | soft                | Midsagittal             |
| N15              | Subnasale                | SN                        | soft                | Left Alare Sagittal     |
| N16              | Subnasale                | SN                        | soft                | Right Alare Sagittal    |
| N17              | Selion                   | S                         | soft                | Orbital                 |
| N18              | Pronasale                | PN                        | soft                | Orbital                 |
| N19              | Subnasale                | SN                        | soft                | Orbital                 |
| N20              | Selion                   | S                         | soft                | Coronal                 |
| N21              | Pronasale                | PN                        | soft                | Coronal                 |
| N22              | Subnasale                | SN                        | soft                | Coronal                 |
| N25              | Selion                   | S                         | soft                | Rhinion                 |
| N27              | Subnasale                | SN                        | soft                | Rhinion                 |
| N41              | Left Alar curvature superior   | ACS_L                | soft                | Midsagittal             |
| N42              | Left Alar curvature posterior  | ACP_L                | soft                | Midsagittal             |
| N43              | Left Nose Alare               | NA_L                 | soft                | Midsagittal             |
| N44              | Left Alar curvature inferior   | ACI_L                | soft                | Midsagittal             |
| N45              | Left Alar curvature superior   | ACS_L                | soft                | Orbital                 |
| N46              | Left Alar curvature posterior  | ACP_L                | soft                | Orbital                 |
| N47              | Left Nose Alare               | NA_L                 | soft                | Orbital                 |
| N48              | Left Alar curvature inferior   | ACI_L                | soft                | Orbital                 |
| N49              | Left Alar curvature superior   | ACS_L                | soft                | Coronal                 |
| N50              | Left Alar curvature posterior  | ACP_L                | soft                | Coronal                 |
| N51              | Left Nose Alare               | NA_L                 | soft                | Coronal                 |
| N52              | Left Alar curvature inferior   | ACI_L                | soft                | Coronal                 |
| N54              | Right Nose Alare              | NA_R                 | soft                | Midsagittal             |
| N58              | Right Nose Alare              | NA_R                 | soft                | Orbital                 |
| N62              | Right Nose Alare              | NA_R                 | soft                | Coronal                 |
| N65              | Right Alar curvature superior  | ACS_R                | soft                | Midsagittal             |
| N66              | Right Alar curvature posterior | ACP_R                | soft                | Midsagittal             |
| N67              | Right Nose Alare              | NA_R                 | soft                | Midsagittal             |
| N68              | Right Alar curvature inferior  | ACI_R                | soft                | Midsagittal             |
| N69              | Right Alar curvature superior  | ACS_R                | soft                | Orbital                 |
| N70              | Right Alar curvature posterior | ACP_R                | soft                | Orbital                 |
| N71              | Right Nose Alare              | NA_R                 | soft                | Orbital                 |
| N72              | Right Alar curvature inferior  | ACI_R                | soft                | Orbital                 |
| N73              | Right Alar curvature superior  | ACS_R                | soft                | Coronal                 |
| N74              | Right Alar curvature posterior | ACP_R                | soft                | Coronal                 |
| N75              | Right Nose Alare              | NA_R                 | soft                | Coronal                 |
| N76              | Right Alar curvature inferior  | ACI_R                | soft                | Coronal                 |


<details>
<summary>Code for comparing the true vs predicted soft tissue landmarks </summary>

```python

import slicer
import numpy as np

def create_soft_tissue_measurement_lines():
    # Get nodes
    try:
        soft_tissue_node = slicer.util.getNode("Ryu_soft_tissue")
        predicted_node = slicer.util.getNode("Predicted_Soft_Landmarks")
    except slicer.util.MRMLNodeNotFoundException as e:
        print(f"Error: {str(e)}")
        return
    
    # Define soft tissue measurements
    soft_tissue_measurements = [
        ("N8", "S", "Midsagittal"), ("N9", "S", "Left Alare Sagittal"), ("N10", "S", "Right Alare Sagittal"),
        ("N11", "PN", "Midsagittal"), ("N12", "PN", "Left Alare Sagittal"), ("N13", "PN", "Right Alare Sagittal"),
        ("N14", "SN", "Midsagittal"), ("N15", "SN", "Left Alare Sagittal"), ("N16", "SN", "Right Alare Sagittal"),
        ("N17", "S", "Orbital"), ("N18", "PN", "Orbital"), ("N19", "SN", "Orbital"),
        ("N20", "S", "Coronal"), ("N21", "PN", "Coronal"), ("N22", "SN", "Coronal"),
        ("N25", "S", "Rhinion"), ("N27", "SN", "Rhinion"),
        ("N41", "ACS_L", "Midsagittal"), ("N42", "ACP_L", "Midsagittal"), ("N43", "NA_L", "Midsagittal"), ("N44", "ACI_L", "Midsagittal"),
        ("N45", "ACS_L", "Orbital"), ("N46", "ACP_L", "Orbital"), ("N47", "NA_L", "Orbital"), ("N48", "ACI_L", "Orbital"),
        ("N49", "ACS_L", "Coronal"), ("N50", "ACP_L", "Coronal"), ("N51", "NA_L", "Coronal"), ("N52", "ACI_L", "Coronal"),
        ("N54", "NA_R", "Midsagittal"), ("N58", "NA_R", "Orbital"), ("N62", "NA_R", "Coronal"),
        ("N65", "ACS_R", "Midsagittal"), ("N66", "ACP_R", "Midsagittal"), ("N67", "NA_R", "Midsagittal"), ("N68", "ACI_R", "Midsagittal"),
        ("N69", "ACS_R", "Orbital"), ("N70", "ACP_R", "Orbital"), ("N71", "NA_R", "Orbital"), ("N72", "ACI_R", "Orbital"),
        ("N73", "ACS_R", "Coronal"), ("N74", "ACP_R", "Coronal"), ("N75", "NA_R", "Coronal"), ("N76", "ACI_R", "Coronal")
    ]
    
    # Create standard measurement lines
    missing_landmarks = set()
    missing_planes = set()
    created_count = 0
    
    for line_name, landmark_name, plane_name in soft_tissue_measurements:
        # Find the landmark in the soft tissue node
        point = None
        for i in range(soft_tissue_node.GetNumberOfControlPoints()):
            if soft_tissue_node.GetNthControlPointLabel(i) == landmark_name:
                point = np.array(soft_tissue_node.GetNthControlPointPosition(i))
                break
        
        if point is None:
            missing_landmarks.add(landmark_name)
            continue
        
        # Try to get the plane
        try:
            plane_node = slicer.util.getNode(plane_name)
        except slicer.util.MRMLNodeNotFoundException:
            missing_planes.add(plane_name)
            continue
        
        # Create the line
        line_node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", line_name)
        
        # Calculate projected point
        plane_normal = np.array(plane_node.GetNormal())
        plane_origin = np.array(plane_node.GetOrigin())
        v = point - plane_origin
        distance = np.dot(v, plane_normal)
        projected_point = point - distance * plane_normal
        
        # Add points
        line_node.AddControlPoint(point)
        line_node.AddControlPoint(projected_point)
        
        # Configure line
        line_node.GetMeasurement('length').SetEnabled(True)
        display_node = line_node.GetDisplayNode()
        display_node.SetColor(0, 0, 1)  # Blue
        display_node.SetSelectedColor(1, 1, 0)  # Yellow
        display_node.SetTextScale(3)
        display_node.SetGlyphScale(1.5)
        
        created_count += 1

    # Create error lines between original and predicted landmarks
    error_lines_count = 0
    for i in range(soft_tissue_node.GetNumberOfControlPoints()):
        landmark_name = soft_tissue_node.GetNthControlPointLabel(i)
        original_point = np.array(soft_tissue_node.GetNthControlPointPosition(i))
        
        # Find corresponding predicted point
        predicted_point = None
        for j in range(predicted_node.GetNumberOfControlPoints()):
            if predicted_node.GetNthControlPointLabel(j) == landmark_name:
                predicted_point = np.array(predicted_node.GetNthControlPointPosition(j))
                break
        
        if predicted_point is None:
            continue
        
        # Create error line
        error_line_name = f"error_{landmark_name}"
        error_line = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLMarkupsLineNode", error_line_name)
        error_line.AddControlPoint(original_point)
        error_line.AddControlPoint(predicted_point)
        
        # Configure error line appearance (burgundy: R=0.5, G=0, B=0.125)
        error_display = error_line.GetDisplayNode()
        error_display.SetColor(0.5, 0, 0.125)  # Burgundy
        error_display.SetSelectedColor(0.7, 0, 0.175)  # Lighter burgundy when selected
        error_display.SetTextScale(2.5)
        error_display.SetGlyphScale(1.2)
        error_display.SetOpacity(0.8)  # Slightly transparent
        
        # Enable distance measurement
        error_line.GetMeasurement('length').SetEnabled(True)
        error_line.GetMeasurement('length').SetName('Error Distance')
        
        error_lines_count += 1
        distance = np.linalg.norm(predicted_point - original_point)
        print(f"Created error line for {landmark_name}: {distance:.2f} mm")

    # Report results
    print("\n=== Results ===")
    if missing_landmarks:
        print(f"Missing {len(missing_landmarks)} landmarks in Ryu_soft_tissue:")
        for name in sorted(missing_landmarks):
            print(f" - {name}")
    
    if missing_planes:
        print(f"\nMissing {len(missing_planes)} planes:")
        for plane in sorted(missing_planes):
            print(f" - {plane}")
    
    print(f"\nCreated:")
    print(f"- {created_count} standard measurement lines (blue)")
    print(f"- {error_lines_count} error lines (burgundy)")
    print(f"Total: {created_count + error_lines_count} lines created")

    slicer.util.delayDisplay(f"Created {created_count + error_lines_count} measurement lines", 3000)

# Execute
try:
    create_soft_tissue_measurement_lines()
except Exception as e:
    slicer.util.errorDisplay(f"Error: {str(e)}")


```

</details>


The picture below shows only the true soft tissue measurements:


![image](https://github.com/user-attachments/assets/e0121e64-57a6-497f-b753-0e432d5a0b19)



The picture below shows the distances between true and predicted soft tissue measurements:


![image](https://github.com/user-attachments/assets/c017c407-d753-4673-a53d-0a40a046c3a0)



## Output
Below is a table of measurements to be expected once the linear measurements of the scene are copied onto the clipboard [Guide to copy measurements to clipboard](https://github.com/esomjai/Forensic-Craniofacial-Approximation-Database/blob/basics/Start%20here%20/004_Copy%20measurements%20to%20clipboard.md#content-summary)


<details>
<summary>Example output </summary>

| ID         | measurement     | in mm        |
|------------|----------------|--------------|
| (unknown)  | N1             | 1.390888299  |
| (unknown)  | N2             | 14.39270332  |
| (unknown)  | N3             | 14.82038597  |
| (unknown)  | N4             | 25.35309405  |
| (unknown)  | N5             | 22.00589708  |
| (unknown)  | N6             | 72.62619371  |
| (unknown)  | N7             | 78.07664694  |
| (unknown)  | N23            | 14.71897288  |
| (unknown)  | N24            | 12.01400919  |
| (unknown)  | N26            | 35.40709597  |
| (unknown)  | N28            | 81.59134763  |
| (unknown)  | N29            | 14.68502648  |
| (unknown)  | N30            | 15.78359162  |
| (unknown)  | N31            | 15.14992376  |
| (unknown)  | N32            | 5.975353906  |
| (unknown)  | N33            | 10.71975353  |
| (unknown)  | N34            | 13.16078047  |
| (unknown)  | N35            | 18.7848349   |
| (unknown)  | N36            | 23.1167537   |
| (unknown)  | N37            | 72.29213352  |
| (unknown)  | N38            | 71.8735073   |
| (unknown)  | N39            | 71.15364679  |
| (unknown)  | N40            | 72.9682245   |
| (unknown)  | N53            | 12.81737384  |
| (unknown)  | N55            | 11.8251401   |
| (unknown)  | N56            | 4.075798939  |
| (unknown)  | N57            | 10.70806529  |
| (unknown)  | N59            | 20.21457881  |
| (unknown)  | N60            | 23.50659263  |
| (unknown)  | N61            | 68.84433055  |
| (unknown)  | N63            | 70.59775209  |
| (unknown)  | N64            | 73.03717297  |
| (unknown)  | Predicted_N17  | 19.74484653  |
| (unknown)  | Predicted_N18  | 13.18536634  |
| (unknown)  | Predicted_N19  | 25.83536634  |
| (unknown)  | Predicted_N20  | 78.82236015  |
| (unknown)  | Predicted_N21  | 99.65358106  |
| (unknown)  | Predicted_N45  | 8.427991034  |
| (unknown)  | Predicted_N69  | 9.903038865  |
| (unknown)  | Predicted_N46  | 17.15862617  |
| (unknown)  | Predicted_N70  | 18.86093411  |
| (unknown)  | Predicted_N47  | 19.11799103  |
| (unknown)  | Predicted_N71  | 20.11162202  |
| (unknown)  | Predicted_N48  | 26.40799103  |
| (unknown)  | Predicted_N72  | 27.46805938  |
| (unknown)  | Predicted_N49  | 84.72981857  |
| (unknown)  | Predicted_N73  | 83.56993193  |
| (unknown)  | Predicted_N50  | 78.18596445  |
| (unknown)  | Predicted_N74  | 78.00177457  |
| (unknown)  | Predicted_N51  | 81.99057385  |
| (unknown)  | Predicted_N75  | 81.19970714  |
| (unknown)  | Predicted_N52  | 83.48750091  |
| (unknown)  | Predicted_N76  | 83.12177457  |
| (unknown)  | N8             | 1.169986866  |
| (unknown)  | N9             | 16.95357848  |
| (unknown)  | N10            | 12.2595108   |
| (unknown)  | N11            | 3.505687262  |
| (unknown)  | N12            | 12.27790435  |
| (unknown)  | N13            | 16.93518493  |
| (unknown)  | N14            | 2.089071538  |
| (unknown)  | N15            | 13.69452008  |
| (unknown)  | N16            | 15.51856921  |
| (unknown)  | N17            | 22.46431851  |
| (unknown)  | N18            | 10.73636034  |
| (unknown)  | N19            | 26.04666731  |
| (unknown)  | N20            | 85.27229816  |
| (unknown)  | N21            | 102.5948571  |
| (unknown)  | N22            | 94.77451833  |
| (unknown)  | N25            | 9.063119614  |
| (unknown)  | N27            | 39.44786621  |
| (unknown)  | N41            | 18.0945497   |
| (unknown)  | N42            | 23.7636938   |
| (unknown)  | N43            | 23.3544715   |
| (unknown)  | N44            | 21.27605284  |
| (unknown)  | N45            | 6.70163926   |
| (unknown)  | N46            | 16.17323154  |
| (unknown)  | N47            | 17.15651354  |
| (unknown)  | N48            | 23.98379524  |
| (unknown)  | N49            | 86.46806716  |
| (unknown)  | N50            | 82.70435475  |
| (unknown)  | N51            | 88.15692408  |
| (unknown)  | N52            | 85.89946648  |
| (unknown)  | N54            | 20.0562932   |
| (unknown)  | N58            | 17.01394725  |
| (unknown)  | N62            | 90.58750503  |
| (unknown)  | N65            | 15.87827184  |
| (unknown)  | N66            | 23.81839668  |
| (unknown)  | N67            | 20.0562932   |
| (unknown)  | N68            | 14.08707742  |
| (unknown)  | N69            | 7.506258698  |
| (unknown)  | N70            | 16.27411658  |
| (unknown)  | N71            | 17.01394725  |
| (unknown)  | N72            | 26.58370995  |
| (unknown)  | N73            | 87.90171941  |
| (unknown)  | N74            | 81.9385394   |
| (unknown)  | N75            | 90.58750503  |
| (unknown)  | N76            | 87.48696634  |
| (unknown)  | error_S        | 7.096907602  |
| (unknown)  | error_PN       | 4.372769124  |
| (unknown)  | error_SN       | 16.71379721  |
| (unknown)  | error_ACS_L    | 3.830485682  |
| (unknown)  | error_ACS_R    | 6.39818841   |
| (unknown)  | error_ACP_L    | 9.776701277  |
| (unknown)  | error_ACP_R    | 12.88518318  |
| (unknown)  | error_NA_L     | 10.44920441  |
| (unknown)  | error_NA_R     | 12.86383378  |
| (unknown)  | error_ACI_L    | 7.015964695  |
| (unknown)  | error_ACI_R    | 4.995331176  |
</details>


#### Research ideas


As noticed during the implementation of the method, the predicted lengths on soft tissue measurements are close to the true measurement, but misplaced - the only reference for their placements are the hard tissue landmark and plane, but not any other position of the line within the plane - this could be investigated by using the [Thitiorul (2020) method](https://github.com/esomjai/Forensic-Craniofacial-Approximation-Database/blob/basics/Nose%20predictions/Thitiorul2020.md) that takes the 3d coordinates of the landmarks to create prediction equations. 


As the original  Ryu et al. 2020[^2] method featured participants of Korean ancestry, other populations may have slightly different relationships between the same measurements/landmarks - therefore investigating whether a "recalibration" (see [Rynn's method](https://github.com/esomjai/Forensic-Craniofacial-Approximation-Database/blob/basics/Nose%20predictions/Rynn's%20(2010)%20method.md)) for other populations is necessary. 


# Bibliography

[^1]: 3D Slicer webpage https://www.slicer.org/
[^2]: Ryu, J. Y., et al. (2020). "Craniofacial anthropometric investigation of relationships between the nose and nasal aperture using 3D computed tomography of Korean subjects." Scientific Reports 10(1): 16077.
[^3]: Ridel et al. (2018). "Skeletal dimensions as predictors for the shape of the nose in a South African sample: A cone-beam computed tomography (CBCT) study." Forensic Science International 289: 18-26.
[^4]: Lee, K.-M., et al. (2014). "Three-dimensional prediction of the nose for facial reconstruction using cone-beam computed tomoraphy." Forensic Science International 236: 194.e191-194.e195.
[^5]: Caple, J. and C. N. Stephan (2016). "A standardized nomenclature for craniofacial and facial anthropometry." International Journal of Legal Medicine 130(3): 863-879.
[^6]: Martin, R. (1928). Lehrbuch der Anthropologie in systematischer Darstellung: mit besonderer Berücksichtigung der anthropologischen Methoden ; für Studierende, Ärzte und Forschungsreisendechichte, Morphologische Methoden. Jena, Gustav Fisher.
[^7]: Knussmann, R. (1988). Anthropologie: Handbuch der vergleichenden Biologie des Menschen, G. Fischer.
[^8]: Pittayapat, P., et al. (2017). "Three-dimensional Frankfort horizontal plane for 3D cephalometry: a comparative assessment of conventional versus novel landmarks and horizontal planes." European Journal of Orthodontics 40(3): 239-248.
[^9]: Howells, W. W. (1937). "The designation of the principle anthrometric landmarks on the head and skull." American Journal of Physical Anthropology 22(3): 477-494.
[^10]: Howells, W. W. (1974). Cranial variation in man: A study by multivariate analysis of patterns of difference among recent human populations. Cambridge, Harvard University.
[^11]: Kolar, J. and E. Salter (1997). Craniofacial anthropometry: practical measurement of the head and face for clinical, surgical, and research use. Springfield, Charles C Thomas.
[^12]: Farkas, L. G. (1994). Anthropometry of the Head and Face, Lippincott Williams & Wilkins.	
[^13]: Buikstra, J. E. and D. H. Ubelaker (1994). Standards for data collection from human skeletal remains. Fayetteville: Arkansas.
Howells (1937)[^9]; Howells (1974)[^10]; Caple & Stephan (2016)[^5]


